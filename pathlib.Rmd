---
jupyter:
  jupytext:
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.10.3
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
  orphan: true
---

# Using the `pathlib` module

The `pathlib` module is one of two ways of manipulating and using file paths in Python.  See the {doc}`path manipulation <path_manipulation.Rmd>` page for more discussion, and {doc}`os_path.Rmd` page for a tutorial on the alternative `os.path` approach.

The primary documentation for `pathlib` is
<https://docs.python.org/3/library/pathlib.html>.

The standard way to use the Pathlib module is to import the `Path` class from the module:

```{python}
from pathlib import Path
```

In Jupyter or IPython, you can tab complete on `Path` to list the methods (functions) and attributes attached to it.

An object (value) of type `Path` represents a pathname.  As you [remember
](path_manipulation.Rmd), a pathname is a string that identifies a
particular file or directory on a computer filesystem.

Let us start by making a default object from the `Path` class, like this:

```{python}
p = Path()
p
```

By default, the path object, here `p`, refers to our current working directory, or `.` for short.   `.` is a *relative path*, meaning that we specify where we are relative to our current directory.  `.` means we are exactly in our current directory.

Because the `.` is a *relative path*, it does not tell us where we are in
the filesystem, only where we are relative to the current directory.

Path objects have an `absolute` function attached to them.  Another way of
saying this is that Path objects have an `absolute` *method*.  Calling
this method gives us the *absolute* location of the path, meaning, the
filesystem position relative to the base location of the disk the file is
on.

```{python}
abs_p = p.absolute()
abs_p
```

Notice the `/` in front of the absolute filename (on Unix), meaning the
base location for all files.  You will see a drive location like `C:` or
similar, at the front of the absolute path, if you are on Windows.


We can always convert the `Path` object to a simple string, using the
`str` function. `str()` converts anything to a string, if it can:

```{python}
# The path, as a string
str(abs_p)
```

The first function we will use from `os.path` is `dirname`.  To avoid
typing `os.path` all the time, we import `os.path` with the shortened name
`op`:

```{python}
abs_p.parent
```

The `parent` attribute of the Path object gives the directory name from a
full file path. It works correctly for Unix paths on Unix machines, and
Windows paths on Windows machines.

```{python}
# On Unix
a_path = Path('/a/full/path/then_filename.txt')
# Show the directory containing the file.
a_path.parent
```

You'll see something like this as output if you run something similar on
Windows.

```
'c:\\a\\full\\path'
```

Notice that, on Windows, you need to use double backslashes, because the
backslash in a Python string is a way of *escaping* a character â€” meaning, to
specify you mean exactly that character.  Double backslash has the meaning
"Yes, I do mean exactly backslash for the next character".

`dirname` also works for relative paths,  A relative path where the starting
directory is relative to the current directory, rather than absolute, in terms
of the root of the file system:

```{python}
# On Unix
Path('relative/path/then_filename.txt').parent
```

Use `basename` to get the filename rather than the directory name:

```{python}
# On Unix
Path('/a/full/path/then_filename.txt').name
```

Sometimes you want to join one or more directory names with a filename to get
a path.   Windows and Unix have different characters to separate directories
in a path.  Windows uses the backslash: `\`, Unix uses a forward slash:
`/`. If your code will run on Windows and Unix, you need to take care that
you get the right character joining your paths.  This is what `os.path.join`
does:

```{python}
# On Unix
Path('relative') / 'path' / 'then_filename.txt'
```

This also works on Windows.  `op.join('relative', 'path', 'then_filename.txt')` gives output `'relative\\path\\then_filename.txt'`.

To convert a relative to an absolute path, use `abspath`:

```{python}
# Show the current working directory
Path('relative/path/then_filename.txt').absolute()
```

Use `suffix` to split a path into: the path + filename; and the file
extension:

```{python}
Path('relative/path/then_filename.txt').suffix
```

`read_bytes`
`read_text`


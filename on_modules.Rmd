---
jupyter:
  jupytext:
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.13.7
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Modules and scripts

```{python}
# Operating system utilities
import os

# Usual imports
import numpy as np
import matplotlib.pyplot as plt
import nibabel as nib
```

We get a 4D volume to work on:

```{python}
# Load the function to fetch the data file we need.
import nipraxis
# Fetch the data file.
data_fname = nipraxis.fetch_file('ds107_sub012_t1r2.nii')
# Show the file name of the fetched data.
data_fname
```

Let’s say I have a function that loads a 4D image, and returns a list with
mean values across all voxels in each volume:

```{python}
def vol_means(image_fname):
    img = nib.load(image_fname)
    data = img.get_fdata()
    means = []
    for i in range(data.shape[-1]):
        vol = data[..., i]
        means.append(np.mean(vol))
    return np.array(means)
```

**For extra points**: can you work out a better way to do the same thing
without a loop?

First we check the `vol_means` function works:

```{python}
my_means = vol_means(data_fname)
plt.plot(my_means)
```

We are interested in outlier detection.  Let's make a routine to detect outliers:

```{python}
def detect_outliers(some_values, n_stds=2):
    overall_mean = np.mean(some_values)
    overall_std = np.std(some_values)
    thresh = overall_std * n_stds
    is_outlier = (some_values - overall_mean) < -thresh
    return np.where(is_outlier)[0]
```

```{python}
outlier_inds = detect_outliers(my_means)
outlier_inds
```

```{python}
my_means[outlier_inds]
```

These seem like useful functions.

We decide we'd like to use these in another notebook.

Of we go and copy / paste these functions into [another
notebook](using_module.Rmd)

Go there, and have a look at how it does on some more data


## Back from trying some more data


We found that the there is a mistake in the copy/pasted code.

Well, of course we could fix it here, and then go and fix it in the other
notebook.

But, a better way, is:

* Put the code in one place, for both notebooks to use
* Fix it in one place, and later
* Test the code!  (More later).

A Python *module* is a Python file with functions (and variables and other
things) that other modules and scripts may use. These other modules and
scripts will `import` the module.

The simplest possible *module* is just a file with a `.py` extension, with
Python code.

Here I'm using the notebook machinery to write out a file to the current working directory.

Usually we would write the file with our text editor.

```{python}
# %%file volmeans.py
""" File to calculate volume means, detect outliers
"""

import numpy as np

import nibabel as nib

def vol_means(image_fname):
    """ Calculate volume means from 4D image `image_fname`
    """
    img = nib.load(image_fname)
    data = img.get_fdata()
    means = []
    for i in range(data.shape[-1]):
        vol = data[..., i]
        means.append(np.mean(vol))
    return np.array(means)


def detect_outliers_fixed(some_values, n_stds=2):
    overall_mean = np.mean(some_values)
    overall_std = np.std(some_values)
    thresh = overall_std * n_stds
    is_outlier = np.abs(some_values - overall_mean) > thresh
    return np.where(is_outlier)[0]
```

We now have a file in the current directory called `volmeans.py`:

```{python}
'volmeans.py' in os.listdir()
```

We can use this module very simply - by `import`ing it, as we have imported
other modules and libraries:

```{python}
import volmeans
```

```{python}
means_again = volmeans.vol_means(data_fname)
volmeans.detect_outliers_fixed(means_again)
```

## On scripts

In fact, what I would really like to do, is to be able to run this file as a *command*, like this:

```
python3 volmeans.py
```

In my ideal world, this would print out the outliers for the scan
`ds107_sub012_t1r2.nii`.

I can do this very simply, by adding some stuff to the end of the module.  I'll rename the module to avoid overwriting the old one, for now:

```{python}
# %%file volmeans_script.py
""" File to calculate volume means, detect outliers
"""

import numpy as np
import nipraxis
import nibabel as nib

def vol_means(image_fname):
    """ Calculate volume means from 4D image `image_fname`
    """
    img = nib.load(image_fname)
    data = img.get_fdata()
    means = []
    for i in range(data.shape[-1]):
        vol = data[..., i]
        means.append(np.mean(vol))
    return np.array(means)


def detect_outliers_fixed(some_values, n_stds=2):
    overall_mean = np.mean(some_values)
    overall_std = np.std(some_values)
    thresh = overall_std * n_stds
    is_outlier = np.abs(some_values - overall_mean) > thresh
    return np.where(is_outlier)[0]


fname = nipraxis.fetch_file('ds107_sub012_t1r2.nii')
means = vol_means(fname)
print(detect_outliers_fixed(means))
```

We import run the `.py` file as we want:

```
!python3 volmeans_script.py
```

We can also run it from Jupyter itself:

```{python}
run volmeans_script.py
```

A script is a file that you can run with `python3 my_script.py`. The script
will usually do some processing, and may print something to the terminal, put
up a plot or save some data to the filesystem.

You store modules in text files ending in `.py`. For example, the module
`mymodule` would be in a file called `mymodule.py`.

A module needs to `import` everything it uses.

You can store scripts with any extension, but it is common to use `.py`
extensions for Python scripts as well.

## The `__name___ == "__main__"` trick

You can execute a module in two different contexts:

* As a script, from the terminal (`python3 my_script.py`);
* Import as a module, from within Python (`>>> import my_script`).

It is reasonably common to want to use your `.py` file in either of these two
ways.  For example, you may want to use and debug the functions in your code
after `import my_script`, and then run the code as a script with `python3
my_script.py`.

How does a Python file know whether it is being executed as a script or
imported as a module?

To help with this problem, Python sets a variable that tells you whether you
are currently being `import`-ed or not.   This is the `__name__` variable.

Notice the double underscores on either side of the variable name.  Variables
with double underscores on either side are often referred to as “dunder”
variables (for Double UNDERscore).  When Python is going to set or use a
variable or method name for its own purposes, it usually uses a dunder name,
as here.

For our purposes `__name__ == "__main__"` if our Python file is running as a
script and `__name__` is set to the module name if the module is being
imported.  For example, if we did `import my_script`, then, when
`my_script.py` gets run, `__name__` will be set to `my_script`.

When you do want to use your `.py` file as a script, or for importing, you
often see this pattern at the bottom of the `.py` file:

```
def main():
    # Only run this function when used as a script
    # The name "main" is only a common convention, the function could have
    # any name.


if __name__ == '__main__':
    # We only get here if running the file as a script
    main()
```

See [`if __name__ ==
'__main__'`](https://docs.python.org/3/library/__main__.html) in the Python
documentation.

## Command line arguments

When you run a script, you can also pass command line arguments, e.g.:

```
python3 my_script.py a_string
```

Here `my_script.py` is the script, and `a_string` is the command line
argument.

You can do the same thing from within IPython:

```
run my_script.py a_string
```

In your script, you can get the command line arguments from the `argv`
list within the `sys` module.  The first element of the `sys.argv` list is
always the name of the program – in our case this will be `my_script.py`.
The second and subsequent entries in `sys.argv` are the arguments entered at
the command line.  For example, in our case:

```
sys.argv == ['my_script.py', 'a_string']
```

The entries in this list are always strings.  For `python3 my_script.py 1`
you would get:

```
sys.argv == ['my_script.py', '1']
```

# Example files

Example files at:

* {download}`mymodule.py`
* {download}`my_script.py`
